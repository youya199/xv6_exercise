# 1. sleep:

## 1.1 code structure:
    
1.1.1 kernel: contains implementation of kernel code.  
1.1.2 user: contains all user level apps, e.g. cat, echo, ls, the shell etc.[note: on a real linux os, "ls" and "vscode" are both user level apps, although one is easy the other one is complex]  

## 1.2 app working flow:
1.2.1 you enter a string into shell(which is a app itself). [e.g. enter "sleep 5" to shell]  

1.2.2 the shell recognize the string, then run for you the corresponding app code (file of .c)[e.g. it runs sleep.c file in /user/sleep.c]   
1.2.3 the real app is on and do the work. [the app sleep.c pauses the os for some time]
## 1.3 working mechanism
1.3.1 inside the app source file, system call is invoked [e.g. inside sleep.c there is a system call wrapper function "sleep(time)"]    
![image](https://github.com/youya199/xv6_exercise/assets/94166804/0a3fdc1b-a8fe-4a74-8914-f60c0410cdac)  
note: the input string is parsed into an array of two entries. first entry is "sleep" and second entry is "5", we see from the pic that only the second entry is used and normally the first entry is ignored coz it's just the name of the cmd.  
1.3.2 the system calls which can be used in app source code are listed in user/user.h, for convenience of app source code developers. [e.g. it declares the system call wrapper int sleep(int); telling developers infos like input parameters]   
![image](https://github.com/youya199/xv6_exercise/assets/94166804/7ce74a10-65db-4691-b452-a9d396927927)


1.3.3 once a system call is invoked by this wrapper, it first goes to kernel mode then execute system call code in kernel. 
First, a mode switch is done by executing a switching assembler code in user/usys.S, in order to switch executing mode from user mode(limited resource access) to kernel mode(all resource access)  
![image](https://github.com/youya199/xv6_exercise/assets/94166804/2aab7869-bb88-4416-924f-7575213f6b9f)   
Second, execute system call in kernel.[the sleep function in this code is different from the system call wrapper which is listed in user/user.h, but rather it is a kernel function, only execute in kernel mode!]  
![image](https://github.com/youya199/xv6_exercise/assets/94166804/24535fd8-8927-4914-9b6a-2733a5e3c306)  


# 2. ping pong:
Refer to textbook page 16.  
## 2.1 structure of process when creating pipe.  
```
1. create pipe: pipe(p);  
2. fork
3. case study: how child behaves, how parent behaves
```
# 3. primes:  
In order to make it simple, we sychronize forking and recursion, i.e., every time we fork a new process, we call the recursion function at the same time point. The pros of this are:  
1. Processes and subfunctions don't cut up blocks and interfere with each other, but are rather unified.
2. Clear intefaces: child process inherits the pipe, recursion passsing parameter is also the same pipe.

![1692697284101-screenshot](https://github.com/youya199/xv6_exercise/assets/94166804/5170a461-aa9f-482d-b87e-16beb0e13977)
Note: make sure the pipes are shut closed in time! Otherwise it would always take the memory.  
# 4. find:
First it's worthwhile to get familiar with the two structs used in ls.c:
```
struct dirent de;
struct stat st;
```
The struct of stat includes infos of an inode.  
The struct of dirent includes all infos of a directory, e.g. for a directory path(fd_di) containing three files 1.c 2.c and 3.c, the info of this directory is:
```
// Entry "1.c"
struct dirent entry_1 = {
    .d_name = "1.c",
    .d_ino = /* Inode number associated with "1.c" */,
    .d_type = /* Type of the entry (e.g., DT_REG) */
};

// Entry "2.c"
struct dirent entry_2 = {
    .d_name = "2.c",
    .d_ino = /* Inode number associated with "2.c" */,
    .d_type = /* Type of the entry (e.g., DT_REG) */
};

// Entry "3.c"
struct dirent entry_3 = {
    .d_name = "3.c",
    .d_ino = /* Inode number associated with "3.c" */,
    .d_type = /* Type of the entry (e.g., DT_REG) */
};
```
If we read(fd_di, buf, sizeof(struct dirent)), means each time we read out one struct to buffer, then we read again(the fd would look after its own offset, it starts to read from where it's left off last time), and it would need 3 reads for this example to read all.
